# 用戶驗證系統升級文檔

## 📋 概述

基於 `07-multi-room-chatapp` 的參考架構，我們已經完善了用戶驗證機制，實現了完整的用戶狀態管理和頁面保護系統。

## 🔧 主要改進

### 1. 認證管理器 (`/public/js/auth.js`)

創建了統一的認證管理類 `AuthManager`，提供以下功能：

- **用戶狀態管理**：統一管理登入/登出狀態
- **會話驗證**：定期檢查會話有效性
- **自動重定向**：根據認證狀態自動跳轉頁面
- **API 請求認證**：自動添加認證頭到 API 請求
- **用戶界面更新**：自動更新用戶名顯示和頭像

### 2. 服務器端頁面保護

在 `server.ts` 中添加了頁面保護中間件：

```typescript
const protectPage = (pageType: "public" | "protected" | "auth") => {
  // 根據頁面類型進行不同的認證檢查
};
```

**頁面類型**：

- `public`：公開頁面（如主頁）
- `protected`：受保護頁面（如計算器頁面）
- `auth`：認證頁面（如登入/註冊頁面）

### 3. 頁面重定向邏輯

#### 未登入狀態下的重定向：

- **主頁** → 登入/註冊 → 賬單計算頁面
- **登入/註冊** → 賬單計算頁面
- **登錄後登出** → 主頁

#### 登入狀態下的重定向：

- **主頁** → 識別到已登入 → 跳轉到賬單計算頁面
- **登入/註冊** → 識別到已登入 → 跳轉到賬單計算頁面

## 📁 文件結構

```
public/
├── js/
│   └── auth.js              # 認證管理器
├── index.html               # 主頁（已更新）
├── login-page.html          # 登入頁面（已更新）
├── registration-page.html   # 註冊頁面（已更新）
└── calculator.html          # 計算器頁面（已更新）

server/
└── server.ts                # 服務器（已更新）
```

## 🔄 認證流程

### 登入流程

1. 用戶在登入頁面輸入憑證
2. 發送登入請求到 `/api/auth/login`
3. 服務器驗證憑證並創建會話
4. 前端保存會話信息到 `AuthManager`
5. 自動重定向到計算器頁面

### 登出流程

1. 用戶點擊登出按鈕
2. 發送登出請求到 `/api/auth/logout`
3. 清除本地會話信息
4. 重定向到主頁

### 頁面保護流程

1. 用戶訪問受保護頁面
2. 服務器檢查認證狀態
3. 如果未認證，重定向到登入頁面
4. 如果已認證，允許訪問

## 🧪 測試場景

### 1. 未登入用戶測試

- [ ] 訪問主頁 → 顯示登入/註冊按鈕
- [ ] 訪問計算器頁面 → 自動重定向到登入頁面
- [ ] 訪問登入頁面 → 正常顯示登入表單
- [ ] 訪問註冊頁面 → 正常顯示註冊表單

### 2. 已登入用戶測試

- [ ] 訪問主頁 → 顯示用戶信息和"開始計算"按鈕
- [ ] 訪問登入頁面 → 自動重定向到計算器頁面
- [ ] 訪問註冊頁面 → 自動重定向到計算器頁面
- [ ] 訪問計算器頁面 → 正常顯示，用戶名正確顯示

### 3. 登出測試

- [ ] 在計算器頁面點擊登出 → 重定向到主頁
- [ ] 在主頁點擊登出 → 重定向到主頁
- [ ] 登出後訪問受保護頁面 → 重定向到登入頁面

### 4. 會話管理測試

- [ ] 會話過期後訪問受保護頁面 → 自動重定向到登入頁面
- [ ] 定期會話驗證 → 自動檢查會話有效性

## 🔐 安全特性

1. **會話管理**：服務器端會話驗證
2. **自動登出**：會話過期自動清除
3. **頁面保護**：服務器端路由保護
4. **API 認證**：所有 API 請求都需要認證
5. **用戶隔離**：每個用戶的數據完全隔離

## 📝 使用說明

### 前端使用

```javascript
// 檢查認證狀態
if (window.authManager.isAuthenticated()) {
  // 用戶已登入
  const user = window.authManager.getCurrentUser();
  console.log("當前用戶:", user.username);
}

// 登出
await window.authManager.logout();

// 發送認證請求
const response = await window.authManager.authenticatedFetch(
  "/api/some-endpoint"
);
```

### 服務器端使用

```typescript
// 保護頁面
app.get("/protected-page", protectPage("protected"), (req, res) => {
  // 只有已認證用戶才能訪問
});

// 認證中間件
app.use("/api/protected", authenticateUser);
```

## 🚀 部署注意事項

1. 確保所有頁面都引入了 `auth.js`
2. 檢查服務器端的頁面保護路由
3. 測試所有重定向邏輯
4. 驗證會話管理功能

## 🔍 故障排除

### 常見問題

1. **用戶名不顯示**：檢查 `authManager.updateUserDisplay()` 是否被調用
2. **登出無效**：檢查 `authManager.setupLogoutButton()` 是否被調用
3. **重定向循環**：檢查頁面保護邏輯是否正確
4. **會話過期**：檢查會話驗證邏輯

### 調試方法

1. 查看瀏覽器控制台日誌
2. 檢查 `localStorage` 中的會話信息
3. 使用網絡面板查看 API 請求
4. 檢查服務器端日誌

## 📈 未來改進

1. **記住登入狀態**：添加"記住我"功能
2. **多設備登入**：支持多設備同時登入
3. **權限管理**：添加用戶角色和權限
4. **社交登入**：支持第三方登入（Google、Facebook 等）
5. **雙因素認證**：增強安全性

---

**升級完成時間**：2025 年 10 月 13 日  
**版本**：v2.0.0  
**狀態**：✅ 完成
